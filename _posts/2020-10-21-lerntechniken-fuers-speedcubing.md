---
layout: post
title: Lerntechniken fürs Speedcubing
subtitle: Damit du lernst, wie man lernt!
tags: [lernen,speedcuben,technik,techniken,wissen,speedcubing,lerntechnik,lernmethoden,algorithmen,anfänger,fortgeschrittene,beginner,advanced,spaced,repetition,verstehen,alg,algs,algos,datenbank,analysieren,vergleichen,fingertricks,muscle,memory,gedächtnis]
---

Vom Auswendiglernen zahlreicher Algorithmen wirst du vielleicht öfter mal abgeschreckt.
Ob es sich um die ersten Speedcubing-Algorithmen überhaupt handelt, oder ob du ein Advanced-Set vor dir hast, die Menge ist jedes Mal wieder frustrierend. Das muss aber eigentlich gar nicht sein, tatsächlich kann dieser Lernprozess sogar Spaß machen!

## Überblick über nützliche Lerntechniken
{:.no_toc}

Das Wort Lerntechniken klingt so theoretisch, dabei lassen sie sich einfach in die Praxis übersetzen. Damit du aber nicht nur auf meine Erfahrung, sondern auch auf Fakten vertrauen kannst, füge ich an passenden Stellen auch die ein oder andere Notiz hinzu. So bekommst du neben der Anwendung der Techniken direkt auch spannende Links zum Thema!

{: .box-warning}
**Beachte:** Gleich zu Beginn: dieser Post wird keine Wunder vollbringen (oder gar die Anzahl zu lernender Algorithmen verringern), aber es sollte schon zu einer gewissen Erleichterung führen. Du verstehst die Tipps natürlich am besten, wenn du schon ein wenig Erfahrung im Speedcuben hast, aber auch Neueinsteiger werden profitieren.

Hier sind die Lerntechniken, die wir uns gleich genauer ansehen werden:
* TOC
{:toc}
* In Lernportionen aufteilen und geschickt planen
* Cases identifizieren: Recognition
* Algorithmen analysieren / vergleichen, Klammern setzen
* Spaced Repetition, sinnvoll wiederholen
* Muscle Memory, Fingertricks
* Best-Practices und Überprüfen des Gelernten
  * "Deliberate Practice" und Non-Zero-Days
  * Kann ich die Cases aus beliebigen Positionen erkennen?
  * Kann ich die Cases auch in Solves anwenden?
  * Algs auf anderen Cubes testen
  * Sind meine Algs noch gut, oder gibt es heutzutage bessere?

## In Lernportionen aufteilen und geschickt planen

Mal ehrlich, wer vor einem Berg zu erlernender Algorithmen steht, denkt sich bestimmt nicht:

> _"Ach wie schön, nur noch 57 OLLs, das schaff ich doch bestimmt am Wochenende! Sieht ja gar nicht so wild aus."_

Wahrscheinlich bist du eher der Meinung, dass so viel Input einiges an Zeit benötigt, und du der Sache nicht gerecht werden wirst.

> _"57 OLLs? Wer soll die denn alle lernen? Fake News, niemand kann sich all diese Algorithmen einprägen!"_

Was ich dir hier zeigen möchte, ist ein gesunder Mittelweg zwischen Unter- und Überschätzen der zu erlernenden Alg-Sets. Algorithmen lernen geht nicht von selbst, nicht über Nacht und ist bestimmt kein Selbstläufer. Allerdings war ich immer wieder davon überrascht, was man selbst schaffen kann, wenn man das Lernen nicht ganz planlos gestaltet. Bereit für ein paar Erfahrungswerte?

{: .box-note}
**Notiz:** Dir ist bestimmt schon mal das ein oder andere Video aus der Reihe "Full OLL in 30 Tagen" begegnet. Wenn nicht, und solltest du entweder gerade Lust auf Nostalgie oder OLLs haben, dann schau mal rein! Warum diese Playlists so erfolgreich sind, wird du bestimmt noch im Laufe des Posts erfahren.

Es klingt eigentlich ganz logisch, die vielen Algorithmen eines Sets (oder gar mehrerer, falls du parallel etwas weiteres lernst) in bestimmte Teile zu gruppieren, die du dann bestimmten Wochen und Tagen zuordnest. Eine grobe Einteilung ergibt sich sicherlich aus den Bezeichnungen ganzer Gruppen von Cases, die sich im Aussehen ähnlich sind. Dabei würdest du bei der gleich folgenden weiteren Differenzierung erst mit neuen Gruppen beginnen, wenn die vorherige fertig ist. Du kannst ja mal klein anfangen, und legst pro Tag einen Algorithmus bzw. einen Fall fest, den du lernen möchtest. Und das ziehst du dann kontinuierlich so durch. Heißt, wir kämen beim Beispiel OLLs auf 57 Tage, in denen du durchhalten musst.

#### Gibt es denn noch andere Strategien, die Algorithmen aufzuteilen, und falls ja, wird es dadurch schwieriger?

Wenn ich meine persönlichen Routinen ansehe, dann lande ich nie bei einem Algorithmus pro Tag. Stattdessen werde ich, wenn ich mich gerade in einer solchen Lernphase befinde, immer auch dazu passende Algorithmen lernen, falls mein Gedächtnis mitspielt. Der Grund für die Erhöhung der Algorithmenanzahl pro Tag ist folgender: es gibt auch unter den vielen verschiedenen Cases immer welche, die sich sehr ähnlich sind. Angefangen dabei, dass sie einer Gruppe angehören (übergeordnete Merkmale, die alle Gruppenmitglieder bezogen auf die Recognition erfüllen), aber auch, wenn Bestandteile des Algs ähnlich oder verwandt sind. Gibt es in der Lösung der Cases ähnliche Merkmale, dann bedeutet ein minimaler Mehraufwand am Tag X einen doppelten "Lernertrag". Klingt doch ganz gut! Aber auch, wenn die Algs nicht aufgrund der verwendeten Moves zueinander gehören, sondern, wenn die Muster ähnlich sind (gespiegelt zum Beispiel), dann lohnt sich das Erlernen des "Partners" am selben Tag. Das macht nicht deshalb Sinn, weil sie sich leichter lernen lassen, sondern weil du in der Recognition schon früher entscheiden kannst, ob du den Case bereits gelernt hast, oder nicht. Greifen wir mal alternativ das Beispiel PLLs auf, dann wärst du definitiv gut beraten, an einem Tag beide R-Perms zu lernen, auch wenn die Algs nicht zu den einfachsten zählen. Denn immer dann, wenn du im Prozess der Recognition auf einen R-Perm stößt (noch bevor du genau weißt, welcher der beiden R-Perms) wird dein Gehirn melden:

> _"Ja kann ich, ist ja schließlich ein R-Perm, und los geht's!"_

Und nicht:
> _"Lass mich erst noch weiter gucken, ob es der eine oder der andere ist, den ich kann, und wenn ich ihn kann, dann mache ich ihn."_

{: .box-note}
**Notiz:** Es wird mit der Zeit schwieriger, dazuzulernen, je mehr man schon gelernt hat. Das zumindest suggeriert die Lernkurve. Klar können wir das im Großen wie im Kleinen beobachten. Wenn ich schon zwei Nachkommastellen von Pi gelernt habe, wird die dritte schwieriger sein, als die beiden ersten. Und bei der vierten muss ich ja sogar die drei vorherigen wiederholen! Möglichst viele Stellen von Pi auswendig zu lernen, hat aber wenig mit dem Auswendiglernen von Algorithmen zu tun. Der Grund: Muster treten bei Pi nicht auf, bei Algorithmen allerdings schon! Wer also Analogien nutzt, um von einem Alg auf einen anderen zu schließen, wird ungleich mehr Algorithmen lernen und anwenden können als jemand, der jeden Alg ohne den Zusammenhang zu anderen lernt. Nicht alles an einem "neuen Alg" ist neu. Algorithmen lernen ist daher vielleicht eher ein "Wiedererkennen" als ein "Einprügeln". Dazu aber später mehr.

#### OK, dann lass mich doch einfach vier Algorithmen pro Tag lernen, dann bin ich schnell fertig

Wir haben gesehen, dass jeder mit der klugen Auswahl mehr als einen Algorithmus pro Tag lernen kann. Und bestimmt fällt es dir auch bei manchen Cases nicht schwer, direkt weiter zu machen. Schließlich erfüllen alle vier G-Perms doch ein Merkmal, nämlich nur den einen Block mit Ecke und Kante. Ach ja und außerdem sind sich H- und Z-Perm doch auch total ähnlich. Geht doch alles an einem Tag und am nächsten dann direkt die nächste Ladung. Ich möchte hier nichts ausschließen, aber einen wichtigen Hinweis geben.

{: .box-error}
**Vorsicht:** Über mehrere Tage hinweg zu viele Algorithmen zu lernen, lässt keinen Spielraum für einen Puffer, indem sich die gelernten Algorithmen auch mal im Langzeitgedächtnis niederlassen können! Ziehe daher lieber einen ganzen Tag ohne neuen Algorithmus vor, wenn du an den vergangenen Tagen dein Pensum voll ausgereizt hast.

Glaube nicht, dass dich eine Pause von einem Tag ohne neuen Algorithmus extrem zurückwerfen wird. Und lass es sogar mehr als einen Tag sein, wenn du noch keine Gelegenheit hattest, die neu gelernten Algorithmen einfach zu trainieren. Einen entscheidenden Punkt in der Planung haben wir nämlich noch vergessen: Puffertage bzw. Tage ohne neue Algorithmen.

#### Ein grober Plan für mittelgroße Algorithmensets

Werden wir nun einfach mal konkret, und zwar am Beispiel der allseits beliebten OLLs. Bei diesem Set kannst du die bisher genannten Tipps sehr schön anwenden.

| Mo | Di | Mi | Do | Fr | Sa | So |
| :--- |:--- | :--- | :--- | :--- | :--- | :--- |
| 2 lernen | 2 lernen | 0 lernen | 2 lernen | 4 lernen | 0 lernen | 2 lernen |
| 2 lernen | 0 lernen | 2 lernen | 4 lernen | 0 lernen | 2 lernen | 4 lernen |
| 0 lernen | 2 lernen | 2 lernen | 0 lernen | 2 lernen | 4 lernen | 0 lernen |
| 2 lernen | 3 lernen | 0 lernen | 2 lernen | 4 lernen | 0 lernen | 2 lernen |
| 2 lernen | 0 lernen | 2 lernen | 4 lernen | 0 lernen | 0 lernen | 0 lernen |

Das sind nun tatsächlich alle 57 Stück, in immerhin nur 32 Tagen, fast wie im Original. Und sogar mit Puffern dazwischen, nicht schlecht! Dabei bin ich davon ausgegangen, dass du noch keinen einzigen OLL kannst. Kommst du mit 2-Look-OLL im Gepäck zu diesem Post, dann lässt sich erneut was einsparen. Für die grobe Planung wäre dann nur noch abzuklären, in welcher Reihenfolge die Cases gelernt werden können.

{: .box-warning}
**Beachte:** Diese Planung ist definitiv nicht verbindlich, sie muss am Ende zu dir und deinen Gewohnheiten oder Vorkenntnissen passen. Wenn dir also schon jetzt oder auch mitten in der Lernphase auffällt, dass der Plan so nicht passt, dann hat keiner ein Problem damit, wenn du ihn änderst. Ich bin dann auch nicht traurig, sondern zufrieden, weil das Gelesene zu einer Transferleistung geführt hat. Also ausprobieren und bei Bedarf anpassen.

## Cases identifizieren: Recognition

Wenn du vor hast, Algorithmen zu lernen, stößt du dabei wahrscheinlich auch auf das Problem, die Cases identifizieren zu müssen. Also noch bevor du dich erinnerst, wie der Algorithmus ausgeführt wird. Wir nennen das Recognition und können auch dafür Techniken üben.

{:.box-note}
**Notiz:** Wenn wir davon sprechen, Algorithmen zu lernen, dann ist damit oft auch der Case insgesamt gemeint, also inklusive der Recognition.

Die Recognition läuft je nach Algorithmenset unterschiedlich ab. Was aber immer hilft, ist die Beschreibung des Cases mit relativen Angaben, nicht mit absoluten. Damit meine ich, dass du dich nicht auf bestimmte Farben konzentrieren solltest, sondern auf die Relation der sichtbaren Farben oder Steine zueinander. Und das sogar, wenn du nicht color-neutral werden willst.

Bei den PLLs solltest du dir beispielsweise nicht sowas merken wie
> _"rechts ist rot, blau, rot, vorne blau, orange und blau, links orange, rot, orange und hinten grün, grün, grün"_,

sondern:

> _"überall gelöste Corners, Kante rechts und Corner vorne haben gleiche Farbe, Kante links und Ecken links entgegengesetze Farbe, hinten alles gelöst"_.

Damit sollte es dann auch leicht werden, jeden PLL nur mit zwei sichtbaren Seiten zu erkennen.

{:.box-error}
**Vorsicht:** Die genannten Bezeichnungen für links, vorne, rechts und hinten sind allerdings nur Platzhalter. Es ist nicht nötig, die obere Ebene so auszurichten, wie in meiner Beschreibung. Weder mit U-Moves, noch mit Rotations, wenn du gute Recognition gelernt hast. Außerdem müssen die Steine der oberen Ebene nicht in einer Relation zu den mittleren und ersten, gelösten Ebenen stehen. Zwar fällt dir dann die Recognition mit zusätzlichen Rotations oder AUFs eventuell anfangs leichter, aber das solltest du dir möglichst schnell wieder abgewöhnen.

Generell: lerne die Recognition so allgemein wie möglich, unabhängig von irgendwelchen Spezialfällen. Überlege dir zum Beispiel für ganze Algsets eine Art Flussdiagramm, wie die Recognition ablaufen kann. Bei den OLLs könnte man sich vorstellen sich erst auf die oben befindlichen Sticker zu konzentrieren, dann festzustellen, ob Kanten oder Ecken nach oben zeigen und wenn ja wie viele. Dann kennst du bereits alles, was du über die Kanten wissen musst, bei den Ecken gibt es aber immer noch verschiedene Orientierungen, die man nur mit dem Blick auf die seitlichen Facets entdecken kann.

## Algorithmen analysieren / vergleichen, Klammern setzen

Schön, wenn wir das Grundgerüst jetzt gelegt haben, um das Lernen zu strukturieren. Was wir da allerdings lernen, ist für Ungeübte oft nur eine chaotische Aneinanderreihung von kryptischen Zeichen, Buchstaben, Zahlen, Strichen. Es macht keinen großen Unterschied, ob du Algorithmen für den 3x3, Skewb, Megaminx, Square-1 oder irgendein anderes Puzzle lernen möchtest: eine Analyse hilft dir, dass du nicht Zeichen für Zeichen lernen musst.

{:.box-warning}
**Beachte:** Die Notation für alle vier genannten Puzzles mag unterschiedlich sein, vielleicht auch auf den ersten Blick nicht so leicht verständlich. Überhaupt gibt es nicht _die_ eine Notation pro Puzzle, sondern je nach Kontext können sich die verwendeten Zeichen unterscheiden. Selbst bebilderte Algorithmen tauchen hin und wieder auf. Um Algorithmen effizient zu lernen, und dabei auch die ganzen Online-Ressourcen zu verstehen, sollte man die gängigen Abkürzungen auf jeden Fall drauf haben.

Was ich in diesem Abschnitt zeigen möchte, passt auf viele Puzzles, mögen sie noch so unterschiedlich sein. Dies ist der zugrundeliegenden Mathematik der Drehpuzzles geschuldet, nämlich der Gruppentheorie. Aber nicht, dass du jetzt einen Mathe-Schock bekommst: wir kommen auch ohne die Suche nach einem x klar, und müssen auch keine Termumformungen machen... nicht mal ableiten.

> _Wir wollen Muster erkennen._

#### Bestandteile erkennen und umordnen

Nehmen wir mal ein Beispiel, oder, wir nehmen direkt zwei: den T-Perm und den Jb-Perm. Wieso macht es Sinn, sich diese Algorithmen anzusehen? Erstens haben sie gemeinsam, dass zwei Kanten und zwei Ecken vertauscht werden. Genauergesagt zwei adjacent (nebeneinanderliegende) Ecken, und dann einmal opposite (gegenüberliegende) Kanten (T) bzw. adjacent Kanten (Jb). Ähnlich ist die Recognition also auf jeden Fall, da so mancher Block bei beiden Cases vorhanden ist.

Zum Lernen der Drehfolgen mag das jetzt noch nicht so viel gebracht haben. Dafür schauen wir uns jetzt mal genau an, was bei beiden beliebten Algorithmen passiert.

> _R U R' U' R' F R2 U' R' U'_ **R U R' F'** (T-Perm),

> **R U R' F'** _R U R' U' R' F R2 U' R' (U')_ (Jb-Perm).

Was gibt es da zu erkennen? Wenn man ganau hinsieht, dann sieht es so aus, als bestünden T- und Ja-Perm aus je zwei Abschnitten, und diese Abschnitte für sich lassen sich tauschen. Damit kommt man von einem Algorithmus zum anderen. Hast du gerade etwas neues gelernt? Dann bitte einmal kurz innehalten und freuen! Das bedeutet nämlich nichts anderes, als dass du mit einem Algorithmus plus diesem leicht zu merkenden Zusatzwissen ganze zwei Cases lösen kannst! Ohne großen Mehraufwand, aber mit viel Verständnis.

Solche Verbindungen solltest du versuchen, herzustellen. Dieses Beispiel ist so schön, weil auch die Fälle sehr beliebt bzw. bekannt sind. Diese Art, die Algorithmen in Teile zu zerlegen, kann die Beliebtheit teilweise erklären.

Machen wir dort weiter, dann kommen wir auch schnell auf den F-Perm, denn auch dort tauchen ähnliche Bestandteile auf:

> R' U' F' _R U R' U' R' F R2 U' R' U'_ R U R' U R (F-Perm).

Beim F-Perm findet sich also ein entscheidenes Segment wieder, was auch schon beim T- und Jb-Perm Verwendung fand.

#### Algorithmen komprimieren

Wir müssen aber nicht immer solche Tauschvorgänge zweier Bestandteile nutzen, um einen neuen Algorithmus zu lernen. Man denke nur mal an OLL 21, und den passenden Algorithmus F R U R' U' R U R' U' R U R' U' F'. Was sich dahinter verbirgt, kann man denke ich schnell sehen: die Sequenz R U R' U' taucht dreimal hintereinander auf. Also tu' doch deinem Gedächtnis einen Gefallen und lerne diesen OLL daher als F (R U R' U')x3 F' statt als lange Variante. Die Information wurde sozusagen komprimiert, ähnlich wie beim Nutzen von .zip-Dateien statt "entpackten" Ordnern, die mehr Speicherplatz brauchen. Dieser Abschnitt lässt sich daher zusammenfassen als: zippe deine Algorithmen!

{.:box-warning}
**Beachte:** Nicht immer sind die Algorithmen, die ich hier in den Beispielen erwähne auch die Algs, die am höchsten gerankt werden oder am beliebtesten sind. Es gibt beispielsweise beim erwähnten OLL auch noch eine kürzere Variante. Diese Algs dienen vorrangig zur Information bzw. Lernzwecken.

Klammern zu setzen ist aber nicht nur dann hilfreich, wenn sich Bestandteile des Algorithmus wiederholen, sondern auch allgemein, um den Algorithmus in Etappen aufzuteilen, die sich zusammenhängend lernen lassen. Eine gute Strategie ist es, sogenannte Trigger in den Algorithmen zu entdecken, das sind kurze Drehfolgen, von etwa vier Moves Länge. Sexy-Move: R U R' U' oder Sledgehammer R' F R F' fallen mir ein, oder auch deren inverse Algs. Aber auch längere Drehfolgen lassen sich als wiederkehrend ausmachen, wenn man sich zum Beispiel den Y-Perm ansieht. Interessanterweise stecken dort zwei OLLs drin, also würde ich diese Teile umklammern.

> (F R U' R' U' R U R' F')(R U R' U' R' F R F') (Y-Perm)

Diese Art, Algorithmen zu analysieren sieht vielleicht erst mal nicht so hilfreich aus, und macht ja auch Arbeit. Der Vorteil liegt aber auf der Hand: erstens wird es so leichter, neue Algorithmen zu lernen, weil nicht Move für Move gelernt werden muss, zweitens beherrschst du für manche Trigger schon gute Fingertricks und Muscle Memory, sodass sich auch der neue Alg anfühlt, als hättest du ihn schon immer gekonnt. Übrigens sprechen wir später noch detaillierter über Muscle Memory.

#### Algorithmen spiegeln

Wer kennt es nicht, gerade einen R-Perm gelernt, der nächste wartet schon und es ist schon wieder so ein langer Algorithmus. Dabei sehen sich die beiden Cases auch noch so ähnlich! Wäre es dann nicht schön, auch das Lernen der Algs etwas zu vereinfachen? Ja! Und dazu nutzen wir die Technik, Algorithmen zu spiegeln. Wortwörtlich spiegeln wir alles, was eine Hand im einen Algorithmus tut, auf die andere Hand, um den gespiegelten Algorithmus zu erhalten, der den gespiegelten Fall lösen kann.

Eine Übersetzungshilfe: U<->U',D<->D',F<->F',B<->B',R<->L',R'<->L Wenn du also einen Alg findest, und möchtest ihn spiegeln, dann kannst du dich an der Hilfe orientieren, den Algorithmus gespiegelt aufschreiben und dann anwenden. Dieser Zwischenschritt ist aber eigentlich nicht nötig, wenn du ausschließlich mit Muscle Memory arbeitest bzw. dir merkst, was deine Finger im Alg A tun. Dort macht dann mehr eine räumliche Vorstellung Sinn als die Singmaster-Notation, also so viel wie: aus rechte Hand nach oben wird linke Hand nach oben. Denn die Übersetzung R wird zu L' ist erst mal gewöhnungsbedürftig. Aus "mit rechtem Zeigefinger flicken" wird "mit linkem Zeigefinger flicken", und das implementiert auch schon den Wechsel zwischen U und U'.

{:.box-error}
**Vorsicht:** Auch wenn dies beim Lernen die Sache vereinfacht, bedeutet es nicht, dass daraus auch gleich gut Fingertricks entstehen, obwohl sie es in der Theorie müssten. Tatsächlich macht es (zumindest für mich) einen riesigen Unterschied, welche Hand für D-Moves zuständig ist. Generell gilt also: selbst wenn das Erlernen des gespiegelten Algs flott ging, bitte immer auch überprüfen, ob die Execution sinnvoll ist, oder nur ein Relikt des Übersetzers. Und dazu kommt noch, dass es manchmal auch komplett unterschiedliche Algs für gespiegelte Cases gibt, die aufgrund der Fingertrick-Freundlichkeit vom bloßen Spiegeln des ersten Algs abweichen können. Daher bitte auch die Schwarmintelligenz befragen und beliebte Algorithmen mit den eigenen vergleichen.

#### Algorithmen invertieren

Außerdem könnten wir zum Beispiel versuchen, aus einem Alg den inversen Alg herzustellen. Oft gibt es dafür nämlich ebenfalls eine Verwendung! Auch diese Gedächtnisstütze kann dir beim Lernen weiterhelfen, da du etwas gerade Gelerntes nur rückwärts ausführen musst, um eventuell ein neues Problem zu lösen. Beispiele wären die U-Perms, G-Perms, A-Perms, aber auch bei OLLs gibt es dieses Phänomen. Bei den PLLs betrifft es die 3-Cycles von Kanten, Ecken, oder der Kombination. Bei den OLLs ist ein sehr einfaches und bekanntes Beispiel der Algorithmus F R U R' U' F' und dessen inverser Algorithmus F U R U' R' F'. In beiden Algorithmen steckt aber noch etwas mehr Struktur dahinter!

{:.box-warning}
**Beachte:** Leider hilft es nicht immer, mit einem Algorithmus und dessen Inversen ein neues Problem zu lösen. Dabei reicht es, eine Ebene höher zu argumentieren, nicht auf Algorithmen, sondern auf Case-Ebene. Der T-Perm (aufgefasst als Case) benötigt den Tauschvorgang zweier Ecken, und zweier Kanten. Der Standard-Alg hinterlässt uns dieselbe "Perspektive" auf den Case wie zuvor. Wenn wir jetzt den T-Perm (egal welchen Alg man dafür verwendet) noch einmal ausführen, dann werden wir den Cube wieder zum Ausgangszustand zurück bringen, es werden wieder die zwei Kanten und zwei Ecken getauscht, die auch beim ersten Mal bertroffen waren. Dieser Algorithmus / Case, so sagt man, hat Ordnung 2. Also nach zwei Ausführung geht es zurück auf Anfang. Der T-Perm selbst, so wie ihn die meisten kennen, verrät auf den ersten Blick nicht, dass er zu sich selbst invers ist. Wenn ich den Alg rückwärts aufschreibe, kommt was anderes raus. Das spielt aber keine Rolle, denn der Case selbst ist schon zu sich selbst invers, daher auch jeder Alg, der den Case a) herstellt oder b) löst. Case herstellen und lösen ist daher ein und dieselbe Sache, zumindest für unser Beispiel! Anders ist es bei Cases mit Ordnung 3, zum Beispiel bei den U-Perms. Führe einen U-Perm am gelösten Cube aus, dann stellst du den anderen Case her. Daher reicht es bei den U-Perms, wenn man einen Alg im Detail lernt, und den anderen nur als "inverse" Variante.

#### Konjugates

Zusammen mit den später erklärten Kommutatoren sind Konjugates ein sehr nützliches Tool, wenn es darum geht, Algorithmen zu analysieren und zu verstehen. Es gibt viel dazu zu sagen, was ich mir für einen Follow-Up-Post aufheben möchte. Hier nur mal die Basics.

Eben haben wir es ja schon gesehen, bei manchen Algorithmen fallen uns interessante Dinge auf. Zum Beispiel dass sich F R U R' U' F' invertieren und für einen anderen Case nutzen lässt. Der Algorithmus selbst verbirgt aber auch noch ein weiteres Geheimnis: man kann eine Klammer einfügen, mit der man sich eine Information weniger merken muss. Schreiben wir mal F (R U R' U') F' auf. Wie wir sehen können, endet der Algorithmus mit dem inversen des Moves, mit dem er begonnen hat. Das heißt nach der Klammer müssen wir nicht lange im Gedächtnis kramen, sondern können uns einfach daran erinnern, dass wir den Beginn rückgängig machen möchten.

{:.box-note}
**Notiz:** Das lässt sich nicht nur leicht merken, sondern schafft davon unabhängig auch eine andere Möglichkeit für Deutungen. Der Algorithmus ist von der Form A B A', das heißt, er besteht aus einem Zwischenteil, der selbst etwas bestimmtes tut, und darum herum gibt es ein anderes Element mit seinem Inversen. Das äußere Element könnte dabei selbst auch aus mehr als einem Move bestehen. Speedcubern ist dies auf natürliche Weise schon begegnet, wenn man von sogenannten Setup-Moves spricht. Ein Setup-Move bereitet den Cube auf den folgenden Teil-Algorithmus vor, und danach wird der Setup-Move rückgängig gemacht. Gängige Praxis ist dies zum Beispiel, wenn man Blindfolded lernt.

Warum funktioniert das aber, oder warum haben Konjugates eine Daseinsberechtigung? Ich könnte hier jetzt mit Gruppentheorie und Normalteilern anfangen. Aber erst mal reicht vielleicht auch ein Beispiel. Nur mal angenommen, ich kenne einen Algorithmus, der drei Kanten tauschen kann. Und lassen wir es mal einen U-Perm sein, z.B. diesen: R U' R U R U R U' R' U' R2. Vielleicht fehlt mir zu meinem Glück aber ein Algorithmus, der nicht die Kanten oben-links, oben-vorne und oben-rechts vertauscht, sondern statt oben-vorne hätte ich gerne unten-vorne. Kann ja sein. Ich kenne aber nur den besagten U-Perm, der kann nur seinen Zweck erfüllen, oben liegende Kanten zu tauschen. Das heißt, ich lasse mir einen Setup-Move einfallen, der die Kante unten-vorne an die Stelle bringt, an der gerade noch oben-vorne lag, aber ohne dabei die beiden anderen relevanten Kanten oben-links und oben-rechts zu verändern. Dann wäre ein M'-Move angebracht. Nun würde ich den U-Perm machen. Und schließlich M, als inversen Move zu M'. Zusammengesetzt könnte man schreiben M' (U-Perm) M. Und hätte sich mal eben einen neuen Algorithmus gebastelt. Was wir hier als "mit Setup-Mover versehen" anwenden, bekommt unter Mathematikern den Titel "konjugieren". Klappt also auch mit mathematischen Objekten, die keine Drehpuzzles sind, aber bestimmte Eigenschaften erfüllen.

Ist konjugieren also was komplett theoretisches, und nur Speedcuber scheinen daran Gefallen gefunden zu haben? Das Wort kommt im engeren Sinne natürlich nur unter gewissen Vorbedingungen zum Einsatz. Aber ein Reallife-Problem, bei wir unterbewusst Setup-Moves und Algorithmen verwenden ist folgendes. Ich denke mal, du weißt, wie man aus einer Flasche trinkt, auch wenn dieser Ablauf mal gelernt werden musste, bis er ins Muscle Memory übergegangen ist. Was du aber noch tun musst, bevor du genüsslich trinken kannst, ahnst du ja bestimmt auch schon: du musst die Flasche öffnen. Ok, also schreiben wir insgesamt: Flasche öffnen (Trinken) Flasche schließen. Was ist, wenn du jetzt nicht aus einer Flasche, sondern aus einem Glas, Becher, einer Dose oder was auch immer trinken willst? Du wirst einen neuen Setup-Move erlernen müssen, mit dem du das Trinken "konjugieren" kannst.

Um diesen Abschnitt aber mit weiteren Beispielen aus der Welt des Cubings zu beenden: ein Y-Perm konjugiert mit R', d.h. ausgeschrieben R' (Y-Perm) R, ist ein COLL!

Und was passiert eigentlich, wenn du einem T-Perm ein M' voranstellst, und nach dem T-Perm ein M machst? Oder statt des M's eine Drehung der unteren Seite, oder auch einfach E-Moves verwendest? Vielleicht hast du es ja erkannt, dass das eine kleine Falle war. Warum diese Konjugates aber nichts weiter sind als die Algorithmen im Mittelteil, kann man ja noch schnell klären. Fautregel: wenn dein Setup (also das A aus A B A') kein Teil verändert, welches an B teilnimmt, dann kann man A und A' auch direkt ganz weglassen. Wenn ich also das Licht anmache (A), dann aus einer Flasche trinke (B) und danach das Licht wieder ausmache (A') dann werde ich zwar aus eine Flasche getrunken haben, aber das Licht ist wieder wie zu Beginn, und dem Trinken hat das auch nicht geschadet (hoffen wir doch). Nur wenn es zwischen dem Setup und dem folgenden Algorithmus Berührungspunkte gibt, sprich, der Setup ändert etwas an den Pieces, die von Teil B behandelt werden können, nur dann macht der Setup überhaupt Sinn.

#### Kommutatoren

Wie wäre es, wenn wir nicht nur Algorithmen der Form A B A', sondern auch noch einen Teil B' am Ende verwenden? Also A B A' B'? Sehr bekannt ist mit Sicherheit der "Sexy Move" R U R' U'. Ansprechend und Fingertrick-freundlich! Dass dieser Alg überhaupt irgendeine Verwendung findet, liegt daran, dass R und U nicht kommutieren. Auch das hat den Ursprung in der Mathematik, und bisweilen erfreut sich dieses Konzept auch in der Theoretischen Physik größter Beliebtheit! Was in der Quantenmechanik Oberservablen wie Ort und Impuls sind, das übernehmen hier Moves zweier angrenzender Seiten. Bei Ort und Impuls gilt: man kann nicht beide gleichzeitig beliebig genau messen, da die beiden Größen nicht kommutieren. Bei R und U gilt: man kann keinen der beiden Moves machen, ohne Pieces zu verändern, die vom anderen Move auch verändert werden. Oder anders: mit dem einen Move beeinflusst man, wie sich der andere verhält. Gibt es dort etwa jetzt auch schon spukhafte Fernwirkung zwischen Basic Moves? Fernwirkung ja, spukhaft nein. Und natürlich gibt es auch Beispiele, die sich anders verhalten.

{:.box-warning}
**Beachte:** Tatsächlich kann man, wenn man sich nur auf einzelne Basic Moves konzentriert (das wären RLUDFB) zu je einem Basic Move nur genau einen weiteren finden, der mit diesem kommutiert (gut, in welche Richtung und ob 90 oder 180 Grad sei egal). Wichtig in diesem Zusammenhang: Basic Moves kommutieren mit dem Move der gegenüberliegenden Seite, aber mit keinem anderen. Alle anderen (das sind vier Stück) sind angrenzend oder adjacent und "touchieren" Teile, die der erste Basic Move auch verarbeitet. Um etwas dann noch "zum Kommutieren" zu bringen, müsste man schon mindestens an A oder B etwas ändern, also hinzufügen. Anders sieht es also aus, wenn man nicht nur einfache Moves in den Kommutator baut, sondern die Bestandteile selbst zusammengesetzt sind. Dann gilt diese einfache Regel nicht mehr, und man muss sich stattdessen anschauen, ob _das Resultat_ von A (kann selbst Kommutator oder was auch immer sein, halt irgendein Alg) die Teile verändert, die in B drankommen sollen.

{:.box-note}
**Notiz:** Bei kommutierenden Bestandteilen A und B ergibt A B A' B' so viel wie gar nichts zu tun. Gar nichts tun, an einem Drehpuzzle (dessen Gruppe durch die Basic Moves generiert wird) nennt man auch die "Identität", abgekürzt in unserem Fall mit einer 1. Die 1 an eine Zahl dran zu multiplizieren, macht ja auch nichts mit dieser Zahl. Von daher, stell dir eine Verkettung von Moves (Algorithmus) einfach als Term vor. Ein Buchstabe ohne Apostroph wäre soviel wie multiplizieren, mit Apostroph dran (gesprochen z.B. inverted, prime, oder Strich) bedeutet so viel wie dividieren. Und nichts tun, ist mit 1 multiplieren. Wenn zwei Moves kommutieren, zum Beispiel U und D (das heißt, wir schreiben so was wie U D U' D'), dann bringt es nichts, diesen Alg sonst wo einzufügen. Er tut ja nichts. In der Sprechweise der Mathematik wäre dies nur eine "geschickte Eins", also eine kompliziert ausgedrückte Identität, die nur dann Sinn ergibt, wenn drum herum noch andere Elemente warten, mit denen man sie verschmelzen kann. Brüche erweitern für Cuber ist das hier! Aber keine Sorge, noch verrückter wird es heute nicht mehr, versprochen.

## Spaced Repetition, sinnvoll wiederholen

Wenn du jetzt denkst, mit der groben Planung wäre schon alles gesagt, was du zum Starten brauchst, dann hast du dir vielleicht noch nicht so viele Gedanken über das "_wie_" gemacht. Wir bleiben sogar mal noch ziemlich abstrakt in diesem Abschnitt, bevor wir uns danach die Algorithmen selbst ansehen. Und zwar geht es um eine Struktur für das Lernen, die sich speziell auf einzelne Tage oder gar Uhrzeiten bezieht.

Dieser Tipp basiert darauf, dass man die Abstände zwischen lernen und wiederholen am Anfang eines Lernprozesses sehr kurz wählen sollte, während die Abstände bis zur nächsten Wiederholung mit der Zeit auch größer ausfallen dürfen. Das kommt dir vielleicht nicht nur von dir selbst bekannt vor (vielleicht denkst du gerade an deinen letzten Vokabeltest), sondern wird auch erforscht. Die Forschung ist aber nicht nur in der Theorie weit gekommen, es gibt sogar Software, die die Abstände zum Wiederholen selbstständig festlegen kann, und sogar darauf reagiert, wie gut du auf eine Frage beim letzten Mal geantwortet hast.

{: .box-note}
**Notiz:** Wovon ich spreche trägt den Namen "Spaced Repetition". Es geht darum, herauszufinden, wie man die Abstände bzw. Lücken zwischen den einzelnen Wiederholungen wählt, um nachhaltig zu lernen. Wenn du mal ein dir unbekanntes Auto fährst, wirst du bestimmt zu Beginn häufig hintereinander auf den Druckpunkt der Kupplung achten müssen, du machst Fehler, du probierst es mehrfach in kurzen Abständen noch einmal. Aber irgendwann genügt es, diesen Ablauf nur noch selten genau zu beobachten und zu erlernen, Automatisierung setzt ein. Die Abstände zwischen den Wiederholungen können größer gemacht werden. Selbst wenn du irgendwann mal wieder in dieses Auto steigst, und du bist zuvor eine Woche zu Fuß gelaufen, benötigst du nicht mehr so lange wie zuvor, um den Ablauf wieder "drin zu haben".
Dieses Themengebiet hat zum Beispiel zwei Tolle Programme hervorgebracht, die nicht nur für die bloßen zeitlichen Intervalle verwendet werden können, sondern sie reagieren auch darauf, wie du auf selbstgewählte Fragen (oder heruntergeladene sogenannte Decks) antwortest. Um es auf die Spitze zu treiben, könntest du deine Algorithmen wie als Karteikarten in einem solchen System hinterlegen, und ein Algorithmus (als Bestandteil des Programms) würde dir gerade die Algorithmen anzeigen, die du am ehesten vergessen hast. Hier wären die beiden sehr interessanten Programme: Anki und SuperMemo.
Wenn du dich mehr für die theoretische Basis interessierst, ist die Psychologie das passende Themengebiet. Man kann das Gehirn zwar nur modellieren (und keinem in den Kopf schauen), doch wenn es darum geht, die Tipps zu verstehen, lohnt sich Hintergrundzuwissen zum Gedächtnis bzw. zur Vergessenskurve. Interessant ist sicher auch, dass es einen Unterschied im gelernten Stoff gibt. Sinnlose Silben (und da würde ich Algorithmen in unser Singmaster-Notation am ehesten einordnen) bleiben definitiv nicht so lange im Gedächtnis wie Reime oder Geschichten. Möglicherweise kennt man das ja von Blindfolded? Oder von beliebten Tutorials? Dort wurde scheinbar einiges richtig gemacht.

#### Konkrete Anwendung

Nur mal angenommen, die Tools wollen wir nicht verwenden (und uns auch noch kein eigenes Programm dafür schreiben), dann geht es bestimmt auch mit einer analogen Variante. Das Grundprinzip lässt sich mit Karteikarten und verschiedenen Boxen umsetzen. In der ersten Box liegen all deine bisher angefangen Algorithmen drin. Du testest, ob du sie kannst, und dann dürfen sie in die nächste Box. Fällt dir die Ausführung des Algs schwer, dann muss dieser Alg leider noch in der ersten Box warten. Die nächste Box öffnest du vielleicht nach einer Stunde wieder, machst den Test mit den dort befindlichen Algs. Auch hier dürfen die Algs wieder eine Box weiter, wenn du sie beherrschst. Andernfalls geht es eine Box zurück (in diesem Fall in die erste). Box Nr. 3 wäre dann eine, die du vielleicht erst einen Tag später wiederholen musst. Weiter ginge es mit einer, die erst am übernächsten Tag dran ist. Und dann so weiter, aber die Schritte werden von Box zu Box größer: zum Beispiel Box 5 nach einer Woche. Ich glaube, du hast das Prinzip verstanden: Algs bzw. Lerninhalte wandern immer eine Box weiter, wenn du sie kannst, ansonsten eine Box zurück. Das Ende tritt sagen wir mal nach circa zwei Wochen ein, was dort ist, und dann hin und wieder mal in Solves genutzt wird, sollte den Weg ins Langezeitgedächtnis gefunden haben. Glückwunsch!

Wenn du dich also oben gefragt hast, wofür die freien Tage genutzt werden können, dann finden dort jetzt deine Wiederholungen mit Hilfe der Boxen statt (die du nicht _wirklich_ benutzen musst, nur als Gedankenstütze). Das geht natürlich ganz gut, wenn man entweder echte Karteikarten nutzt oder ein Tool, welches dir den Case zeigt (oder den Alg um ihn herzustellen).
